\documentclass[12pt]{report}
\title{System validation document}
\date{\today \\ Version 0.0.1}

\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{a4wide}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{url}
\usepackage{caption}
\usepackage[parfill]{parskip}
\usepackage{appendix}
\usepackage{subcaption}
\usepackage{color}
\usepackage{booktabs}
\usepackage{lineno}
\usepackage{float}
\usepackage{longtable}
\usepackage{colortbl}
\usepackage{amsfonts}
\newcounter{counter}
\usepackage{listings}

%\linenumbers
\modulolinenumbers[5]

\begin{document}
	\begin{titlepage}
		\begin{center}
			\textsc{\Large EINDHOVEN UNIVERSITY OF TECHNOLOGY}\\[1.5cm]
			
			\textsc{\Large System Validation}\\[0.8cm]
			\hrule
			\vspace{0.5cm}
			{ \huge \bfseries EUV Wafer Stepper \\[0.4cm] }
			\hrule
			\vspace{1.5cm}
			\noindent
			\begin{minipage}[t]{0.5\textwidth}
				\begin{flushleft} \large
					\emph{Authors:}\\
					R.M. van den Hurk (0817761)\\
					Z. Ben Snaiba (0748095)\\
					P.M.M. van Wesel (0818131)\\
				\end{flushleft}
			\end{minipage}\\
			\vspace{5cm}
			\begin{minipage}[t][8cm]{0.3\textwidth}
				\begin{flushright} \large
					\today
				\end{flushright}
			\end{minipage}
			
			\vfill
			
		\end{center}
	\end{titlepage}
	
	\tableofcontents
	
	\chapter{System overview}
	
	\section{System overview}
	\begin{figure}
		\centering
		\includegraphics[scale=0.7]{schematicoverview}
		\caption{A schematic overview of the system}
		\label{fig:overview}
	\end{figure}
	The Extreme Ultraviolet (EUV) Wafer Stepper is a system developed by ASML to treat silicon wafers for the manufacturing of integrated circuits. Treating a wafer is the act of projecting an image with ultra violet light onto a silicon wafer. Since ultra violet radiation is absorbed by air, this treatment has to happen in a vacuum to ensure the accuracy of the projection. This means wafers will have to enter and exit the system through airlocks, also referred to as sluices. One robot will move wafers from the input to the airlocks or from the airlocks to the output for treated wafers from outside the vacuum chamber. One robot will move wafers from the airlocks to a buffer rack inside the vacuum chamber and vice versa for treated wafers. A last robot, located inside the vacuum chamber, takes wafers from the internal buffer rack to the projector and back once the projector is done. A schematic overview of the system can be found in figure \ref{fig:overview}.
	\section{System components}
	The system can be broken down into individual components to be considered by the software. These components are the following:
	\begin{itemize}
	\item \textbf{Input} - A rack containing untreated wafers located outside of the vacuum chamber.
	\item \textbf{Output} - A rack for treated wafers outside the vacuum chamber.
	\item \textbf{Airlocks} - An array of airlocks providing entrance into the vacuum chamber. Each airlock consists of an inner door, outer door, vacuum pump and air pressure sensor.
	\item \textbf{Buffer Rack} - The buffer rack located inside the vacuum chamber that can temporarily hold wafers.
	\item \textbf{Projector} - The projector inside the vacuum chamber that treats the wafers.
	\item \textbf{Robot A} - The robot that can reach \emph{Input}, \emph{Output} and the \emph{Airlocks}.
	\item \textbf{Robot B} - The robot inside the vacuum chamber that can reach the \emph{Airlocks} and \emph{Buffer Rack}.
	\item \textbf{Robot C} - The other robot inside the vacuum chamber that can reach the \emph{Buffer Rack} and \emph{Projector}.
	\end{itemize}
	
	\chapter{System requirements}
	
	\newcommand{\req}[1]{
		\item[\textbf{R\stepcounter{counter}\arabic{counter}}] {#1}
		\hrule
	}
	
	\newcommand{\reqb}[2]{
		\item[\textbf{{#1}}] {#2}
		\hrule
	}
	
	\section{Liveness requirement}
	\begin{itemize}
		\req{If the system is operating normally, an untreated wafer on the input rack will enter the system, and exit the system after it has been treated.}
	\end{itemize}
	
	\section{Sluice requirements}
	\begin{itemize}
		\req{Only one sluice door can be open at a time.}
		\req{The outer sluice door can only open if there is normal air pressure inside the sluice.}
		\req{The inner sluice door can only open if there is a vacuum inside the sluice.}
		\req{The vacuum pump can only make a vacuum if both sluice doors are closed.}
		\req{The doors of a sluice can not close if a robot is reaching inside.}
	\end{itemize}
	
	\section{Sluice robot requirements}
	\begin{itemize}
		\req{Robot A may only move to a sluice if the outer door of the target sluice is open.}
		\req{Robot B may only move to a sluice if the inside door of the target sluice is open.}
		\req{Robot A\&B may only choose a sluice to put a wafer in that is empty.}
		\req{Robot A\&B may only try to retrieve a wafer from an occupied sluice.}
		\req{Robot A\&B can only put a wafer on an empty spot on the rack.}
		\req{Robot A\&B may only target functioning sluices.}
		\req{Robot A\&B should only try to take wafers from the rack if there are wafers available.}
		\req{Robot B may not access the same spot on the rack as Robot C at the same time.}
	\end{itemize}
	
	\section{Inside robot requirements}
	\begin{itemize}
		\req{Robot C can not access the same spot on the rack as Robot B at the same time.}
		\req{Robot C can not put a wafer on the projection platform when it is occupied.}
		\req{Robot C can not take a wafer from the projection platform if the projection is not done.}
		\req{Robot C can not put a wafer on an occupied place on the rack.}
	\end{itemize}
		
	\section{Projector requirements}
	\begin{itemize}
		\req{The projector only starts its treatment when a wafer is on the projection platform.}
	\end{itemize}
	
	\chapter{System interactions}
\section{User actions}
	\begin{itemize}
\item OpenOuterDoor(N) - Open the outer door of sluice N.
\item CloseOuterDoor(N) - Close the outer door of sluice N.
\item OpenInnerDoor(N) - Open the inner door of sluice N.
\item CloseInnerDoor(N) - Close the inner door of sluice N.
\item PumpVacuum(N) - Make a vacuum in sluice N.
\item ReleaseVacuum(N) - Release the vacuum in sluice N.

\item RobotFromInput( W ) - Robot A picks up wafer W from the input rack.
\item RobotToOutput( W ) - Robot A deposits wafer W on the output rack.

\item RobotToSluice( R, S, W ) - Robot R deposits wafer W it is holding in sluice S.
\item RobotFromSluice( R, S, W ) - Robot R picks up wafer W from sluice S.

\item RobotToRack( R, P, W ) - Robot R deposits wafer W it is holding to position P on the buffer rack.
\item RobotFromRack( R, P, W ) - Robot R takes wafer W from position P on the buffer rack.

\item RobotToProjector( W ) - Robot C deposits wafer W it is holding on the projector.
\item RobotFromProjector( W ) - Robot C picks up wafer W that is currently on the projector.

\item TreatWafer( W ) - The projector treats wafer W.
\end{itemize}

	\section{System events}
	\begin{itemize}
\item RobotReset( R ) - Robot R has reset to its default position.
\item OuterDoorOpened( S ) - The outer door of sluice S has completely opened.
\item OuterDoorClosed( S ) - The outer door of sluice S has completely closed.
\item InnerDoorOpened( S ) - The inner door of sluice S has completely opened.
\item InnerDoorClosed( S ) - The inner door of sluice S has completely closed.
\item VacuumDone( S ) - The vacuum in sluice S is complete.
\item VacuumReleased( S ) - The vacuum in sluice S is completely released.
\item WaferTreated( W ) - Wafer W is treated by the projector.
	\end{itemize}
	
	\chapter{Requirements in terms of interactions}
	\section{Liveness requirement}
	\begin{itemize}
		\reqb{SR1}{If a wafer w appears on the input rack, we should see the following sequence of actions. Other actions can happen between any two of these actions, provided they are not one of those two actions with different parameters.\\
		\begin{itemize}
\item RobotFromInput(w )
\item RobotToSluice( $R_a$, s ) \emph{- For some arbitrary sluice s}
\item RobotFromSluice( $R_b$, s ,w)
\item RobotToRack( $R_b$, p2, w) \emph{- For some arbitrary position p2 on the inner} rack.
\item RobotFromRack( $R_c$, p2 ,w ) 
\item RobotToProjector( w ) 
\item TreatWafer(w)
\item RobotToRack( $R_c$, p3, w ) \emph{- For some arbitrary position p3 on the inner rack.}
\item RobotFromRack( $R_b$, p3, w )
\item RobotToSluice( $R_b$, s2, w ) \emph{- For some arbitrary sluice s2.}
\item RobotFromSluice( $R_a$, s2,w )
\item RobotToOutput( w )
\end{itemize}
}
	\end{itemize}
	
	\section{Sluice requirements}
	\begin{itemize}
		\reqb{SR2}{OpenOuterDoor(N) can only happen after InnerDoorClosed(N) if no OpenInnerDoor(N) happened in between.}
		\reqb{SR3}{OpenOuterDoor(N) can only after VacuumReleased(N) if no PumpVacuum(N) happened in between.}
		\reqb{SR4}{OpenInnerDoor(N) can only happen after PumpVacuum(N) if no ReleaseVacuum(N) happened in between(}
		\reqb{SR5}{PumpVacuum(N) can only happen after InnerDoorClosed(N) and OuterDoorClosed(N) if no OpenInnerDoor(N) or OpenOuterDoor(N) happened in between.}
		\reqb{SR6}{
\begin{itemize}		
		\item CloseInnerDoor(N) can only happen after RobotReset(R) if no  RobotToSluice(R) or RobotFromSluice(R) happened in between. \emph{For R $\subset{R_a, R_b}.$}
\item closeInnerDoor(N) can only happen if robotInSluice(N) is false.
\end{itemize}		
		}
	\end{itemize}
	
	\section{Sluice robot requirements}
	\begin{itemize}
		\reqb{SR7}{RobotToSluice($R_a$,N,w) or RobotFromSluice($R_a$,N,w) can only happen after OuterDoorOpened(N) if no CloseOuterDoor(N) happened in between.}
		\reqb{SR8}{RobotToSluice($R_b$,N,w) or RobotFromSluice($R_b$,N,w) can only happen after InnerDoorOpened(N) if no InnerOuterDoor(N) happened in between.}
		\reqb{SR9}{\begin{itemize}
		\item  RobotToSluice($R_a$, N, w) can only happen if \# RobotToSluice($R_a$, N, w) - \# RobotFromSluice($R_b$, N, w) = 0
		\item  RobotToSluice($R_b$, N, w) can only happen if \# RobotToSluice($R_b$, N, w) - \# RobotFromSluice($R_a$, N, w) = 0
		\end{itemize}}
		\reqb{SR10}{\begin{itemize}
		\item  RobotFromSluice($R_a$, N, w) can only happen if \# RobotToSluice($R_b$, N, w) - \# RobotFromSluice($R_a$, N, w) > 0
		\item  RobotFromSluice($R_b$, N, w) can only happen if \# RobotToSluice($R_a$, N, w) - \# RobotFromSluice($R_b$, N, w) > 0
		\end{itemize}}
		\reqb{SR11}{\begin{itemize}
		\item  RobotToRack($R_a$, P, w) can only happen if \# RobotToRack($R_a$, P, w) - \# RobotFromRack($R_b$, P, w) = 0
		\item  RobotToRack($R_b$, P, w) can only happen if \# RobotToRack($R_b$, P, w) - \# RobotFromRack($R_a$, P, w) = 0
		\end{itemize}}
		\reqb{SR12}{RobotToSluice(R, N, w) and RobotFromSluice(R,N,w) can only happen if SluiceBroken(N) has not happened for all \emph{For R $\subset{R_a, R_b}.$}}
		\reqb{SR13}{\begin{itemize}
		\item  RobotFromRack($R_a$, P, w) can only happen if \# RobotToRack($R_a$, P, w) - \# RobotFromRack($R_b$, P, w) > 0
		\item  RobotFromRack($R_b$, P, w) can only happen if \# RobotToRack($R_b$, P, w) - \# RobotFromRack($R_a$, P, w) > 0
		\end{itemize}}
		\reqb{SR14}{RobotToRack($R_b$,P,w) can not happen after RobotToRack($R_c$,P,w) happened without RobotReset($R_c$) in between.}	\end{itemize}
	
	\section{Inside robot requirements}
	\begin{itemize}
		\reqb{SR15}{RobotToRack($R_c$,P,w) can not happen after RobotToRack($R_c$,P,w) happened without RobotReset($R_b$) in between.}	
		\reqb{SR16}{RobotToProjector(w) can if \# RobotToProjector(w) - \# RobotFromProjector(w) = 0.}
		\reqb{SR17}{RobotFromProjector(w) can not happen if WaferTreated(w) has not happened.}
		\reqb{SR18}{
		 RobotToRack($R_c$, P, w) can only happen if \# RobotToRack($R_c$, P, w) - \# RobotFromRack($R_b$, P, w) = 0}
	\end{itemize}
	\section{Projector requirements}
	\begin{itemize}
		\reqb{SR19}{
				TreatWafer(w) can only happen if WaferToProject(w) happened with no WaferFromProjector(w) in between.
		}
	\end{itemize}
	
	\chapter{System model}
	\section{Model overview}
	\begin{figure}
		\centering
		\includegraphics[scale=0.7]{schematicoverview}
		\caption{A schematic overview of the software components}
		\label{fig:components}
	\end{figure}
	To verify the system, a model of the software to be made. The software is split up into the following three components:
	\begin{itemize}
	\item \textbf{SluiceManager} - This component manages the sluices, it runs parallel for each sluice. The purpose of this component is to control the individual airlocks.
	\item \textbf{RobotManager} - This component manages the different robots in the system, and runs a parallel process for each robot.
	\item \textbf{ProjectorManager} - The projector is managed by this component.
	\item \textbf{RackManager} - This component's purpose is to monitor the rack.
	\end{itemize}
	
	A schematic view of this system can also be found in figure \ref{fig:components}.
	
	\section{Formal model}
	%Sorts
	\textbf{sort}\\
	\phantom{----} Wafer = \textbf{struct} \emph{wafer}$( id:\mathbb{Z}, treated:\mathbb{B} )$;\\
	\phantom{----} WaferSet = Set( Wafer );\\
	\phantom{----} WaferList = List( Wafer );\\
	\phantom{----} RobotID = \textbf{struct} $R_a | R_b | R_c$;\\
	\phantom{----} SluiceID = \textbf{struct} $S_0 | S_1$;\\
	\phantom{----} SluiceDoorState = \textbf{struct} $inner\_open|closed|outer\_open$;\\
	\\
	%Params
	\textbf{eqn}\\
	\phantom{----} RackSize = 2;\\
	\phantom{----} NumWafers = $X$;\\
	\phantom{----} NumSluices = 2;\\
	\phantom{----} Dummy = \emph{wafer}$( -1, false)$;\\
	\\
	%Helper equations
	\textbf{eqn}\\
	\phantom{----} IsTreated( \emph{wafer}$( w, b )$ ) = $b$;\hfill for all $w \in \mathbb{Z}, b \in \mathbb{B}$\\
	\phantom{----} IsDummy(  \emph{wafer}$( w, b )$ ) = $w == -1$;\hfill for all $w \in \mathbb{Z}, b \in \mathbb{B}$\\
	\phantom{----} OnRack$( p ) = 0 \leq p < \text{RackSize}$;\hfill for all $p \in \mathbb{N}$\\
	\phantom{----} TreatedWafer(  \emph{wafer}$( w, b )$ ) =  \emph{wafer}$( w, true )$;\hfill for all $w \in \mathbb{Z}, b \in \mathbb{B}$\\
	\\
	\phantom{----} \emph{for all $l \in \text{WaferList}, p \in \mathbb{N}, w \in \text{Wafer}$, where OnRack($p$) = true}:\\
	\phantom{----} PutInList$( l, p, w )$ = [];\hfill if $l=[]$\\
	\phantom{----} PutInList$( l, p, w )$ = $w$ $|>$ PutInList$( tail( l ), p, w )$;\hfill if $0 < \#l \land \#l = \text{RackSize} - p$\\
	\phantom{----} PutInList$( l, p, w )$ = $ head( l )$ $|>$ PutInList$( tail( l ), p, w )$;\hfill if $0 < \#l \land \#l \neq \text{RackSize} - p$\\
	\\
	\phantom{----} InitRack( 0 ) = [];\\
	\phantom{----} InitRack( n ) = InitRack( n - 1 ) $<|$ Dummy;\hfill for all $n \in \mathbb{N}$\\
	\\
	\phantom{----} InitWaferList( 0 ) = [];\\
	\phantom{----} InitWaferList( n ) = InitWaferList( n - 1 ) $<|$ \emph{wafer}($n$, \emph{false});\hfill for all $n \in \mathbb{N}$\\
	\\
	%Processes
	{\small
	%Robot
	\textbf{proc}\\
	\phantom{---} R( \emph{rID}:RobotID, $occupied$:$\mathbb{B}$, $w$:Wafer, $in$:WaferList, $out$:WaferSet, $c$:$\mathbb{N}$ ) =\\
	\phantom{-------} \emph{rID} = $R_a \rightarrow$\\
	\phantom{----------} $occupied$ $\rightarrow$\\
	\phantom{--------------} IsTreated($w$)$\rightarrow$RobotToOutput($w$)$\cdot$RobotReset(\emph{rID})$\cdot$R(\emph{rID},$false$,Dummy,$in$,$out$+$\{w\}$,$c$)\\
	\phantom{--------------} $\Diamond \sum\nolimits_{s \in \text{SluiceID}}\cdot$R2S\_R(\emph{rID},$s$,$w$)$\cdot$RReset\_O(\emph{rID})$\cdot$R(\emph{rID},$false$, Dummy,$in$,$out$,$c$+$1$)\\
	\phantom{----------} $\Diamond$\\
	\phantom{--------------} $in \neq [] \land c < NumSluices \rightarrow$ ( RobotFromInput( head($in$) )$\cdot$\\
	\phantom{---------------------} RobotReset(\emph{rID}))$\cdot$R(\emph{rID},$true$,head($in$),tail($in$),$out$,$c$) ) \\
	\phantom{--------------} + $\sum\nolimits_{w_2 \in \text{Wafer}, s \in \text{SluiceID}}$S2R\_R(\emph{rID},$s$,$w_2$)$\cdot$RReset\_D(\emph{rID})$\cdot$R(\emph{rID}, $true$,$w_2$,$in$,$out$,$c$-$1$)\\
	\\
	\phantom{-------} + \emph{rID} = $R_b \rightarrow$\\
	\phantom{----------} $occupied$ $\rightarrow$\\
	\phantom{--------------} IsTreated($w$)$\rightarrow\sum\nolimits_{s\in\text{SluiceID}}$R2S\_R(\emph{rID},$s$,$w$)$\cdot$RReset\_O(\emph{rID})$\cdot$R(\emph{rID},\emph{false},Dummy,$in$,$out$,$c$)\\
	\phantom{--------------} $\Diamond \sum\nolimits_{p\in \mathbb{N}}$OnRack($p$)$\rightarrow$R2Rack\_R(\emph{rID},$p$,$w$)$\cdot$RReset\_O(\emph{rID})$\cdot$R(\emph{rID},\emph{false},Dummy,$in$,$out$,$c$)
	\phantom{----------}  $\Diamond$\\
	\phantom{--------------} $\sum\nolimits_{w_2 \in \text{Wafer}, s \in \text{SluiceID}}$S2R\_R(\emph{rID},$s$,$w_2$)$\cdot$RReset\_D(\emph{rID})$\cdot$R(rID,\emph{true},$w_2$,$in$,$out$,$c$)\\
	\phantom{--------------} +$\sum\nolimits_{w_2 \in \text{Wafer}, p \in \mathbb{N}}$IsTreated($w_2$)$\land$OnRack($p$)$\rightarrow$Rack2R\_R(\emph{rID},$p$,$w_2$)$\cdot$\\
	\phantom{-----------------------------} RReset(\emph{rID})$\cdot$R(\emph{rID},\emph{true},$w_2$,$in$,$out$,$c$)\\
	\\
	\phantom{-------} + \emph{rID} = $R_c \rightarrow$\\
	\phantom{----------} $occupied$ $\rightarrow$\\
	\phantom{--------------} R2P\_R($w$)$\cdot$RReset\_O(\emph{rID})$\cdot$P2R\_R(TreatedWafer($w$))$\cdot$RReset\_D(\emph{rID})$\cdot\sum\nolimits_{p \in \mathbb{N}}$OnRack($p$)$\rightarrow$\\
	\phantom{------------------} R2Rack\_R(\emph{rID},$p$,TreatedWafer($w$))$\cdot$RReset\_O(\emph{rID})$\cdot$R(\emph{rID},\emph{false},Dummy,$in$,$out$,$c$)\\
	\phantom{----------} $\Diamond$\\
	\phantom{--------------} +$\sum\nolimits_{w_2 \in \text{Wafer}, p \in \mathbb{N}}\neg$IsTreated($w_2$)$\land$OnRack($p$)$\rightarrow$Rack2R\_R(\emph{rID},$p$,$w_2$)$\cdot$\\
	\phantom{-----------------------------} RReset\_D(\emph{rID})$\cdot$R(\emph{rID},\emph{true},$w_2$,$in$,$out$,$c$);
	}\\
	\\
	%Sluice
	{\small
	\phantom{---} S( $id$:SluiceID, $occupied$:$\mathbb{B}$, $w$:Wafer, $door$:DoorState, $broken$:$\mathbb{B}$ ) =\\
	\phantom{------} $\neg broken \rightarrow$\\
	\phantom{---------} $\neg occupied \rightarrow$\\
	\phantom{-------------} $door=outer\_open \rightarrow\sum\nolimits_{w_2\in \text{Wafer}}$R2S\_S($R_a$,$id$,$w_2$)$\cdot$RReset\_D($R_a$)$\cdot$CloseOuterDoor($id$)$\cdot$\\
	\phantom{-----------------} OuterDoorClosed($id$)$\cdot$PumpVacuum($id$)$\cdot$VacuumDone($id$)$\cdot$S($id$,\emph{true},$w_2$,$closed$,\emph{false})\\
	\phantom{-------------} + $door=inner\_open \rightarrow\sum\nolimits_{w_2\in \text{Wafer}}$R2S\_S($R_b$,$id$,$w_2$)$\cdot$RReset\_D($R_b$)$\cdot$CloseInnerDoor($id$)$\cdot$\\
	\phantom{-----------------} InnerDoorClosed($id$)$\cdot$ReleaseVacuum($id$)$\cdot$VacuumReleased($id$)$\cdot$S($id$,\emph{true},$w_2$,$closed$,\emph{false})\\
	\phantom{---------} $\Diamond$\\
	\phantom{-------------} $door=outer\_open \rightarrow$S2R\_S($R_a$,$id$,$w$)$\cdot$RReset\_O($R_a$)$\cdot$S($id$,\emph{false},Dummy,$door$,\emph{false})\\
	\phantom{-------------} + $door=inner\_open \rightarrow$S2R\_S($R_b$,$id$,$w$)$\cdot$RReset\_O($R_b$)$\cdot$S($id$,\emph{false},Dummy,$door$,\emph{false})\\
	\phantom{---------} + $door=closed \land \text{IsTreated}(w) \rightarrow$\\
	\phantom{-------------} OpenOuterDoor($id$) $\cdot$ OuterDoorOpened($id$) $\cdot$ S($id$, $occupied$, $w$, $outer\_open$, \emph{false})\\
	\phantom{---------} + $door=closed \land \neg\text{IsTreated}(w) \rightarrow$\\
	\phantom{-------------} OpenInnerDoor($id$) $\cdot$ InnerDoorOpened($id$) $\cdot$ S($id$, $occupied$, $w$, $inner\_open$, \emph{false})\\
	\phantom{---------} + SluiceBroken($id$) $\cdot$ S($id$, $occupied$, $w$, $door$, \emph{true});\\
	}
	
	%Projector
	{\small
	\phantom{---} P( $occupied$:$\mathbb{B}$, $w$:Wafer ) =\\
	\phantom{------} $occupied\rightarrow$\\
	\phantom{---------} TreatWafer($w$)$\cdot$WaferTreated($w$)$\cdot$P2R\_P(TreatedWafer($w$))$\cdot$RReset\_O($R_c$)$\cdot$P(\emph{false},Dummy)\\
	\phantom{------} $\Diamond$\\
	\phantom{---------} $\sum\nolimits_{w_2\in \text{Wafer}}$ R2P\_P($w_2$) $\cdot$ RReset\_D($R_c$) $\cdot$ P(\emph{true}, $w_2$);
	}
	
	%Rack
	{\small
	\phantom{---} Rack( $wl$:WaferList ) =\\
	\phantom{-------} $\sum\nolimits_{w\in \text{Wafer}, p \in \mathbb{N}, r \in \text{RobotID}}$ OnRack($p$) $\rightarrow$ IsDummy( $wl.p$ ) $\rightarrow$\\
	\phantom{-----------} R2Rack\_Rack($r$, $p$, $w$) $\cdot$ RReset\_D($r$) $\cdot$ Rack(PutInList($wl$, $p$, $w$))\\
	\phantom{-------} + $\sum\nolimits_{p \in \mathbb{N}, r \in \text{RobotID}}$ OnRack( $p$ ) $\rightarrow \neg$IsDummy($wl.p$)$\rightarrow$\\
	\phantom{-----------} Rack2R\_Rack($r$, $p$, $wl.p$) $\cdot$ RReset\_O( $r$ ) $\cdot$ Rack(PutInList($wl$, $p$, Dummy));
	}
	
	%Initialisation\\
	$\nabla_{\text{ \{RobotToSluice, RobotFromSluice, RobotToProjector, RobotFromProjector, RobotToRack, RobotFromRack,}}$\\
	\phantom{--} $_{ \text{ RobotFromInput, RobotFromOutput,}}$\\
	\phantom{--} $_{ \text{ CloseOuterDoor, CloseInnerDoor, OpenInnerDoor, OpenOuterDoor, PumpVacuum, ReleaseVacuum,}}$\\
	\phantom{--} $_{ \text{ RobotReset, WaferTreated, OuterDrooOpened, OuterDoorClosed, InnerDoorOpened, InnerDoorClosed, VacuumDone, VacuumReleased, SluiceBroken\}}}$(\\
	\phantom{---} $\Gamma_{\{R2S\_R|R2S\_S\rightarrow RobotToSluice,S2R\_S|S2R\_R\rightarrow RobotFromSluice,}$\\
	\phantom{-----} $_{ R2P\_R|R2P\_P\rightarrow RobotToProjector, P2R\_P|P2R\_R\rightarrow RobotFromProjector,}$\\
	\phantom{-----} $_{ R2Rack\_R|R2Rack\_P\rightarrow RobotToRack, Rack2R\_P|Rack2R\_R\rightarrow RobotFromRack,}$\\
	\phantom{-----} $_{ RReset\_O|RReset\_D\rightarrow RobotReset \}}$(\\
	\phantom{---------} R( $R_a$, \emph{false}, $Dummy$, \emph{InitWaferList(NumWafers)}, $\emptyset$, 0 ) $||$\\
	\phantom{---------} R( $R_b$, \emph{false}, $Dummy$, [], $\emptyset$, 0 ) $||$\\
	\phantom{---------} R( $R_c$, \emph{false}, $Dummy$, [], $\emptyset$, 0 ) $||$\\
	\phantom{---------} Rack( $InitRack(RackSize)$ ) $||$\\
	\phantom{---------} S( $S_0$, \emph{false}, $Dummy$, $outer\_open$, \emph{false} ) $||$\\
	\phantom{---------} S( $S_1$, \emph{false}, $Dummy$, $outer\_open$, \emph{false} ) $||$\\
	\phantom{---------} P( \emph{false}, $Dummy$ )\\
	\phantom{---} )\\
	);
	
	\chapter{Verification}

    \section{Requirement verification}

    \textbf{Traceability matrix}\\
    \begin{tabular}{| l | l | l | }
        \hline
        Requirement ID & System Requirement ID & Modal formula ID \\ \hline
        R1 & SR1 & MCF1 \\ \hline
        R2 & SR2 & MCF2inner, MCF2outer \\ \hline
        R3 & SR3 & MCF3 \\ \hline
        R4 & SR4 & MCF4 \\ \hline
        R5 & SR5 & MCF5 \\ \hline
        R6 & SR6 & MCF6a1, MCF6a2, MCF6b1, MCF6b2 \\ \hline
        R7 & SR7 & MCF71, MCF72 \\ \hline
        R8 & SR8 & MCF82, MCF82 \\ \hline
        R9 & SR9 & MCF9a, MCF9b \\ \hline
        R10 & SR10 & MCF10a, MCF10b \\ \hline
        R11 & SR11 & MCF11 \\ \hline
        R12 & SR12 & MCF12 \\ \hline
        R13 & SR13 & MCF13b, MCF13c \\ \hline
        R14 & SR14 & MCF14 \\ \hline
        R15 & SR15 & MCF15 \\ \hline
        R16 & SR16 & MCF16 \\ \hline
        R17 & SR17 & MCF17 \\ \hline
        R18 & SR18 & MCF18 \\ \hline
        R19 & SR19 & MCF19 \\  \hline
    \end{tabular}

    \pagebreak

    \textbf{Modal $\mu$-calculus formulas}\\
    \begin{longtable}{p{\textwidth}}
        \textbf{MCF1}\\
        $[true^{\star}] \forall w \in Wafer. [TreatWafer(w).\overline{RobotToOutput(w)}^{\star}.RobotToOutput(w)]false$\\
        \hline

        \textbf{MCF2inner}\\
        $\forall s \in SluiceID.[true^{\star}.InnerDoorOpened(s).\overline{InnerDoorClosed(s)}^{\star}.OpenOuterDoor(s)]false$\\
        \hline

        \textbf{MCF2outer}\\
        $\forall s \in SluiceID.[true^{\star}.OuterDoorOpened(s).\overline{OuterDoorClosed(s)}^{\star}.OpenInnerDoor(s)]false$\\
        \hline

        \textbf{MCF3}\\
        $[true^{\star}] \forall s \in SluiceID. [PumpVacuum(s).\overline{ReleaseVacuum}^{\star}.OpenOuterDoor(s)]true$\\
        \hline

        \textbf{MCF4}\\
        $\forall s \in SluiceID.[true^{\star}.ReleaseVacuum(s).\overline{PumpVacuum}^{\star}.OpenInnerDoor(s)]true$\\
        \hline

        \textbf{MCF5}\\
        $\forall s \in SluiceID.[true^{\star}.(OpenInnerDoor(s).\overline{InnerDoorClose(s)}^{\star}.PumpVacuum(s) \vee OpenOuterDoor(s).\overline{OpenOuterDoorClose(s)}^{\star}.PumpVacuum(s))]false$ \\
        \hline

        \textbf{MCF6a1}\\
        $[true^{\star}] \forall w \in Wafer, s \in SluiceID.[RobotFromSluice(Ra,s,w).\overline{RobotReset(Ra)}$ \\
        $.CloseOuterDoor(s)]false$\\
        \hline

        \textbf{MCF6a2}\\
        $[true^{\star}] \forall w \in Wafer, s \in SluiceID.[RobotToSluice(Ra,s,w).\overline{RobotReset(Ra)}$ \\
        $.CloseOuterDoor(s)]false$\\
        \hline

        \textbf{MCF6b1}\\
        $[true^{\star}] \forall w \in Wafer, s \in SluiceID.[RobotFromSluice(Rb,s,w).\overline{RobotReset(Rb)}$ \\
        $.CloseOuterDoor(s)]false$\\
        \hline

        \textbf{MCF6b2}\\
        $[true^{\star}] \forall w \in Wafer, s \in SluiceID.[RobotToSluice(Rb,s,w).\overline{RobotReset(Rb)}$ \\
        $.CloseOuterDoor(s)]false$\\
        \hline

        \textbf{MCF71}\\
        $[true^{\star}] \forall s \in SluiceID.[OuterDoorClosed(s).\overline{OuterDoorOpened}^{\star}]$ \\
        $\forall w \in Wafer. [RobotToSluice(Ra,s,w)]false$\\
        \hline

        \textbf{MCF72}\\
        $[true^{\star}] \forall s \in SluiceID.[OuterDoorClosed(s).\overline{OuterDoorOpened}^{\star}]$ \\
        $\forall w \in Wafer. [RobotFromSluice(Ra,s,w)]false$\\
        \hline

        \textbf{MCF81}\\
        $[true^{\star}] \forall s \in SluiceID.[InnerDoorClosed(s).\overline{InnerDoorOpened(s)}^{\star}]$ \\
        $\forall w \in Wafer. [RobotToSluice(Rb, s, w)]false$\\
        \hline

        \textbf{MCF82}\\
        $[true^{\star}] \forall s \in SluiceID.[InnerDoorClosed(s).\overline{InnerDoorOpened(s)}^{\star}]$ \\
        $\forall w \in Wafer. [RobotFromSluice(Rb, s, w)]false$\\
        \hline

        \textbf{MCF9a}\\
        $[true^{\star}] \forall w1,w2 \in Wafer, s in SluiceID.[RobotToSluice(Ra,s,w1).\overline{RobotFromSluice(Rb,s,w1)}^{\star}$ \\
        $.RobotToSluice(Ra,s,w2)]false$\\
        \hline

        \textbf{MCF9b}\\
        $[true^{\star}] \forall w1,w2 \in Wafer, s in SluiceID.[RobotToSluice(Rb,s,w1).\overline{RobotFromSluice(Ra,s,w1)}^{\star}$ \\
        $.RobotToSluice(Rb,s,w2)]false$ \\
        \hline

        \textbf{MCF10a}\\
        $[true^{\star}] \forall w \in Wafer, s \in SluiceID. [\overline{RobotToSluice(Rb,s,w)}^{\star}.RobotFromSluice(Ra,s,w)]$ \\
        $false$ \\
        \hline

        \textbf{MCF10b}\\
        $[true^{\star}] \forall w \in Wafer, s \in SluiceID. [\overline{RobotToSluice(Ra,s,w)}^{\star}.RobotFromSluice(Rb,s,w)]$ \\
        $false$ \\
        \hline

        \textbf{MCF11}\\
        $[true^{\star}] \forall p \in \mathbb{N}, r \in RobotID, w \in Wafer. [RobotToRack(r,p,w).\overline{RobotFromRack(r,p,w)}^\star$ \\
        $.RobotToRack(r,p,w)]false$ \\
        \hline

        \textbf{MCF12} \\
        $[true^{\star}] \forall s \in SluiceID [SluiceBroken(n).true^{\star}.(CloseInnerDoor(s) \vee CloseOuterDoor(s) \vee OpenInnerDoor(s) \vee OpenOuterDoor(s) \vee PumpVacuum(s) \vee ReleaseVacuum(s) \vee SluiceBroken(s))]false$\\
        \hline

        \textbf{MCF13b} \\
        $[true^{\star}] \forall p \in \mathbb{N}, w \in Wafer.[\overline{RobotToRack(Rb,p,w}^{\star}.RobotFromRack(Rc, p, w)]false$ \\
        \hline

        \textbf{MCF13c} \\
        $[true^{\star}] \forall p \in \mathbb{N}, w \in Wafer.[\overline{RobotToRack(Rc,p,w}^{\star}.RobotFromRack(Rb, p, w)]false$ \\
        \hline

        \textbf{MCF14} \\
        $[true^{\star}] \forall p \in \mathbb{N}, w \in Wafer. [(RobotToRack(Rc,p,w) \vee RobotFromRack(Rc,p,w)).\overline{RobotReset(Rc}^{\star}.(RobotRack(Rb,p,w) \vee RobotFromRack(Rb,p,w)]false$ \\
        \hline

        \textbf{MCF15} \\
        $[true^{\star}] \forall p \in \mathbb{N}, w \in Wafer. [(RobotToRack(Rb,p,w) \vee RobotFromRack(Rb,p,w)).\overline{RobotReset(Rb}^{\star}.(RobotRack(Rc,p,w) \vee RobotFromRack(Rc,p,w)]false$ \\
        \hline

        \textbf{MCF16} \\
        $[true^{\star}] \forall w\in Wafer. [RobotToProjector(w).\overline{RobotFromProjector(w)}^{\star}]$ \\
        $\exists w2 \in Wafer.[RobotToProjector(w2)]false$ \\
        \hline

        \textbf{MCF17} \\
        $[true^{\star}] \forall w \in Wafer. [RobotToProjector(w).\overline{TreatWafer(W)}^{\star}.RobotFromProjector(w)]false$ \\
        \hline

        \textbf{MCF18} \\
        $[true^{\star}] \forall w \in Wafer, p \in \mathbb{N}. [RobotToRack(Rc, p, w).\overline{RobotFromRack(Rb,p,w)}^{\star}]$ \\
        $\exists w2 \in Wafer.[RobotToRack(Rc,p,w2)]false$ \\
        \hline

        \textbf{MCF19} \\
        $[true^{\star}] \forall w \in Wafer. [RobotToProjector(w).true^{\star}.RobotFromProjector(w).true^{\star}$ \\
        $.TreatWafer(w)]false$ \\
        \hline
    \end{longtable}
	
	\section{Verification procedure}
	Several steps were taken to verify the correctness of this model. First, the model was translated into mCRL2 syntax. Next, all modal formulas were translated into the mcf format used by the mCRL2 tools. Once both translations were done, a linear process specification was generated from the mCRL2 input. This LPS was used to verify the requirements by generating a parameterized boolean expression system for each modal formula.\\
	For the verification of the system release version 201409.1.13218 of the mCRL2 tools was used.\\
	\\
	The system was verified for wafer counts from 1 to 5 to avoid any statespace problems. This should nonetheless present an accurate view of the system, as the maximum amount of wafers inside the vacuum chamber is at most the number of sluices, which is two.
	
	\section{Verification results}
	Results of the verification: matrix numwafers x requirement, value = true/false.	
	
	\chapter{Appendix A}

	\lstinputlisting[breaklines=true]{mcrl2-model/euv_waferstepper.mcrl2}
	\chapter{Appendix B}
	Modal formulas in mcrl format

\end{document} 